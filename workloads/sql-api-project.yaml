apiVersion: v1
kind: Secret
metadata:
  name: db-secrets
type: Opaque
stringData:
  user: python-app
  password: 1f2d1e2e67df
  
---  

kind: Deployment
apiVersion: apps/v1
metadata:
  name: mysql
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mysql-api
      project: backend
  strategy: ## Setting a rolling update strategy is vital to ensure smooth versioning
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: mysql-api
        project: backend
    spec:
      affinity:
        ##set anti affinity to avoid having all the pods from this workload on the same node in case of node failure
        podAntiAffinity: 
          ## Only using prefered to avoid scheduling complications, the rule is not required
          preferredDuringSchedulingIgnoredDuringExecution: 
          weight: 50
            podAffinityTerm:
              labelSelector:
                app: mysql-api
                project: backend
              topologyKey: kubernetes.io/hostname
    securityContext: 
      ##Ensure the pod does not have root access to the host
      runAsNonRoot: FALSE
    containers:
    - name: mysql
      image: mysql:latest
      env:	
      - name: MYSQL_DATABASE		
        value: titanic
      - name: MYSQL_RANDOM_ROOT_PASSWORD	
        value: yes	
      - name: MYSQL_USER	
        secretKeyRef: 	
          name: db-secrets	
          key: user	
      - name: MYSQL_PASSWORD	
        secretKeyRef: 	
          name: db-secrets	
          key: password
      ports:
      - containerPort: 3306
        name: mysql-port
      resources
      ## Based on some base line testing on local machine and providing some headroom to avoid resource limitations
        requests:
          cpu:
          memory:
        limits:
        ## About 40% higher than request to allow for surging, HPA should ensure a good distribution of requests across pods
          cpu:
          memory:
      readinesProbe:
      
      livenessProbe:
      
      volumeMounts:
      ##DB is strored here
      - name: db-storage
        mountPath: /var/lib/mysql
  ###Use openEBS CAS for storage    
    volumes:
    - name: db-storage


---

kind: HorizontalPodAutoscaler
apiVersion: autoscaling/v1
metadata:
  name: mysql-hpa
spec:
  maxReplicas: 10
  minReplicas: 2
  targetCPUUtilizationPercentage: 75
  scaleTargetRef:
    kind: Deployment
    name: mysql
    
---

kind: Service
apiVersion: v1
metadata:
  name: my-sql
spec:
  selector:
    matchLabels:
      app: mysql-api
      project: backend      
  ports:
  - port: 3306

---

kind: Deployment
apiVersion: apps/v1
metadata:
  name: api
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mysql-api
      project: frontend
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: mysql-api
        project: frontend
        spec:
      affinity:
        ##set anti affinity to avoid having all the pods from this workload on the same node in case of node failure
        podAntiAffinity: 
          ## Only using prefered to avoid scheduling complications, the rule is not required
          preferredDuringSchedulingIgnoredDuringExecution: 
          weight: 50
            podAffinityTerm:
              labelSelector:
                app: mysql-api
                project: frontend
              topologyKey: kubernetes.io/hostname
    securityContext: 
      ##Ensure the pod does not have root access to the host
      runAsNonRoot: FALSE
    containers:
    - name: my-api
      image: [determine repo] ##my containerized API
      resources:
        requests:
        limits:
